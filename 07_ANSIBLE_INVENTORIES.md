# Working with ansible inventories

How to use ansible when you have different VMs and different roles for each VM?
This is where `inventories` come in.

Inventories let you define the various `hosts` and `groups` them logically.
You can then use selector `patterns` to select hosts and groups for specific ansible runs.

In the previous chapter, we did not use an inventory file.
This is because Vagrant generates a default inventory file that is good enough for most trivial cases.

However, for more complex use cases, it is advisable to specify the inventory file ourselves.

It is still possible to use the Vagrant API to specify the inventory, but we would like to reuse the ansible code for VMs that are not provisioned by Vagrant, so let us separate the concerns of spinning up the VMs (vagrant) and configuring the VMs. (ansible)


## Using a basic local inventory file.

Let us bring up two VMs using Vagrant using a JSON configuration file.


Create the following `cluster.json` file

```
{
    "nodes": [
        {
            "host_name": "web-01",
            "port_mappings": [
                { "guest_port": 80, "host_port": 8083, "host_ip": "127.0.0.1" },
                { "guest_port": 22, "host_port": 22003, "host_ip": "127.0.0.1" }
            ],
            "network_configs": [
                { "ip": "192.167.32.3", "name": "vboxnet0", "adapter": 2 }
            ]
        },
        {
            "host_name": "db-01",
            "port_mappings": [
                { "guest_port": 80, "host_port": 8084, "host_ip": "127.0.0.1" },
                { "guest_port": 22, "host_port": 22004, "host_ip": "127.0.0.1" }
            ],
            "network_configs": [
                { "ip": "192.167.32.4", "name": "vboxnet0", "adapter": 2 }
            ]
        }
    ]
}
```

Use the following `Vagrantfile`

```
# -*- mode: ruby -*-
# vi: set ft=ruby :

nodes_config = (JSON.parse(File.read("cluster.json")))['nodes']

Vagrant.configure("2") do |config|

  nodes_config.each do |node|

    config.vm.define node["host_name"] do |vm_config|

      vm_config.vm.box = "hashicorp/bionic64"
      vm_config.vm.hostname = node["host_name"]

      vm_config.vm.provider "virtualbox" do |vb|
        vb.memory = 512
        vb.cpus = 1
      end

      port_mappings = node["port_mappings"]

      port_mappings.each do |port_mapping|
        vm_config.vm.network "forwarded_port", 
          guest: port_mapping["guest_port"], 
          host: port_mapping["host_port"], 
          host_ip: port_mapping["host_ip"]
      end

      network_configs = node["network_configs"]

      network_configs.each do |network_config|
        vm_config.vm.network "private_network", 
            ip: network_config['ip'], 
            name: network_config['name'], 
            adapter: network_config['adapter']
      end
    end
  end

  config.vm.provision "ansible" do |ansible|
    ansible.playbook = "playbook.yaml"
    ansible.inventory_path = "inventory.yaml"
  end
  
end


```

Here, we are spinning up a 2 cluster VM by reading the configuration file. 
We are using the ansible provisioner and using a playbook called `playbook.yaml` to configure the VMs.
We have also specified an additional file valled `inventory.yaml` where we specify the VM inventory to the ansible provisioner.


Create the required files using the following command:

```
mkdir db web db/tasks web/tasks
touch playbook.yaml inventory.yaml db/tasks/main.yaml web/tasks/main.yaml
```


Modify the `inventory.yaml` to contain the following contents.

```
---

all:
  children:
    webservers:
      hosts:
        web-01:
          ansible_host: 127.0.0.1
          ansible_port: 22003 
          ansible_private_key_file: .vagrant/machines/web-01/virtualbox/private_key
    dbservers:
      hosts:
        db-01:
          ansible_host: 127.0.0.1
          ansible_port: 22004 
          ansible_private_key_file: .vagrant/machines/db-01/virtualbox/private_key
```

Let us inspect the contents of the `inventory.yaml` in a bit more detail

Here in the inventory, we have specified 2 `groups` called `webservers` and `dbservers`.
In the `playbook.yaml` we will use these group names to associate roles with them.

The `webservers` group contains one VM called `web-01` and the `dbservers` group contains one VM called `db-01`.

Each of the hosts have 3 variables declared: `ansible_host`, `ansible_port` and `ansible_private_key_file`.


Also, note that we have specified the host names and the port names and the private key file to connect to the ansible VM. And, the ansible ports are the same ports that we have mapped to port 22 in the respective guest VMs in the `cluster.json`. This is because are using a custom inventory file and not using the default inventory generated by Vagrant. Hence, the information is duplicated.


Modify the `playbook.yaml` file to contain the following contents.

```
---

- name: Configure web servers
  hosts: webservers
  roles:
    - web
  become: true


- name: Configure db servers
  hosts: dbservers
  roles:
    - db
  become: true
```

Modify the `db/tasks/main.yaml` to contain the following contents.

```
---

- name: Install postgres
  apt:
    name:
      - postgresql
      - postgresql-contrib
    state: present
    update_cache: true

```


Modify the `web/tasks/main.yaml` to contain the following contents:

```
---

- name: Install nginx
  apt:
    name: nginx
    state: present
    update_cache: true
```

Now, run `vagrant up`. You should see the VMs getting provisioned, with each VM getting configured as per the respective roles.


## Dynamic inventory.

Static inventories are useful for trivial cases where the number of VMs are fairly static. But in large scale cloud systems, the number of VMs keep changing dynamically to respond to business needs. So it is useful to read determine the inventory programmatically. 

Ansible provides a feature called `Dynamic Inventory` where the inventory file can be a script or an executable, instead of a static file. The API for a dynamic inventory is rather simple.


### Dynamic Inventory API

#### The inventory file should be executable

The specified file should be executable from the command prompt. 

#### Upon invocation with flag `--host`, should print an inventory json to console.

Upon invocation with flag `--host` it should print a valid inventory json. Here is what the inventory file for the example from the static inventory looks like:

```
{
    "webservers": {
        "hosts": ["web-01"]
    }, 
    "dbservers": {
        "hosts": ["db-01"]
    }, 
    "_meta": {
        "hostvars": {
            "web-01": {
                "ansible_host": "127.0.0.1", 
                "ansible_port": "22003", 
                "ansible_private_key_file": ".vagrant/machines/web-01/virtualbox/private_key"
            }, 
            "db-01": {
                "ansible_host": "127.0.0.1", 
                "ansible_port": "22004", 
                "ansible_private_key_file": ".vagrant/machines/db-01/virtualbox/private_key"
            }
        }
    }
}
```

#### Upon invocation with the flag --host [hostname] it should print the variables for the given host

Suppose we pass the command line parameters `--host web-01` to the script, it should print the following output:

```
{
    "ansible_host": "127.0.0.1", 
    "ansible_port": "22003", 
    "ansible_private_key_file": ".vagrant/machines/web-01/virtualbox/private_key"
}
```

### Implementing a dynamic inventory API

Given the dynamic inventory API requirements, it should be pretty straightforward to implement it.

Let us implement a dynamic inventory script.

Create a file called `inventory.py` and set its permissions such that it is executable.

```
touch inventory.py
chmod +x inventory.py
```

Modify the contents of the inventory file as follows:

```
#!/usr/bin/env python

import os
import sys
import argparse
import json

class ExampleInventory(object):

    _inventory = {
        'webservers': {
            'hosts': ['web-01'],
        },
        'dbservers': {
            'hosts': ['db-01'],
        },
        '_meta': {
            'hostvars': {
                'web-01': {
                    'ansible_host': '127.0.0.1',
                    'ansible_port': '22003',
                    'ansible_private_key_file': '.vagrant/machines/web-01/virtualbox/private_key'
                },
                'db-01': {
                    'ansible_host': '127.0.0.1',
                    'ansible_port': '22004',
                    'ansible_private_key_file': '.vagrant/machines/db-01/virtualbox/private_key'
                }
            }
        }
    }

    _empty_inventory = {'_meta': {'hostvars': {}}}

    def __init__(self):
        
        self.read_cli_args()

        if self.args.list:  # Called with `--list`
            print(json.dumps(self._inventory))

        elif self.args.host:  # Called with `--host [hostname]`
            print(json.dumps(self.get_host_vars(self.args.host)))
        
        else: 
            print(json.dumps(self._empty_inventory))
        

    def get_host_vars(self, hostname):
        return self._inventory['_meta']['hostvars'][hostname]


    # Read the command line args passed to the script.
    def read_cli_args(self):
        parser = argparse.ArgumentParser()
        parser.add_argument('--list', action='store_true')
        parser.add_argument('--host', action='store')
        self.args = parser.parse_args()


# Get the inventory.
ExampleInventory()

```


Let us now test the script to verify that it executes as per the Inventory API requirements.

Execute the following commands and verify the output:

```
./inventory.py --list
```

```
./inventory.py --host web-01
```

The outputs should be as described above.

Now run `vagrant up` to verify that the script works as expected. The output should be similar to the output from the previous example.

It should be obvious that as long as the script prints out the expected output as per the API specification, the logic can be anything. You can, for example, get the inventory from a database. Or, you can invoke the API of your cloud provider to get a list of currently running VMs and their metadata and print the output accordingly.


Here is a simple fun exercise. Define all the details required by the `Vagrantfile` as well as the `inventory.py` in a JSON or a YAML file, or even a database of your choice. Then read that from both the `Vagrantfile` and the `inventory` file to extract the metadata required by each of them!

